{% extends 'd2_api/base.html' %}

{% block content %}

  <h3>Welcome to restit</h3>
  <p>
    A simple Django project to illustrate how to pull data from the RESTful <a href = "https://github.com/Bungie-net/api">Destiny 2 api</a> into your database using forms. This is strongly recommended in Two Scoops of Django. For instance in the section 'Validate All Incoming Data with Django Forms', they say:
  </p>

      <blockquote style="font-family: Courier, Monaco, monospace, sans-serif;">
        Django's forms are a wonderful framework designed to validate Python dictionaries. While most of the time we use them to validate incoming HTTP requets containing POST, there is nothing limiting them to be used just in this manner...What's really nice about this practice is that rather than cooking up our own validation system for incoming data, we're using the well-proven data testing fremwork built into Django.
    </blockquote>

  <p>
    The project, as mentioned above, is extremely simple: it simply shows how to 1) make a call to bungie, 2) extract user information, and then 3) bind this information to a form. To get the process started you need to enter the user's name on the <a href = "{% url 'd2_api:submit' %}">Submit user page</a>.
  </p>


  <h3>Why use forms?</h3>
  <p>
   There are many benefits of using forms to handle new data:
  </p>
    <ol>
        <li><b>Portability.</b> When you use the built-in django methods for validating/saving to a database, it should work no matter what kind of db you have configered (sqlite, postgres, etc). Django's methods abstract away from such details.</li>

        <li><b>Great built-ins.</b> There are excellent built-in methods for validating the data in a form (<i>form.is_valid()</i>), and saving it to your database (<i>form.save())</i>). The validation method returns pre-formatted error messages if it doesn't work. This relieves you of having to maintain complex validation code.</li>

        <li><b>No more 'legacy' databases.</b> There is no need to figure out how to integrate a pre-existing database into your django project: <i>everything</i> is part of your django project from the start. No more wrangling with <i>inspectdb</i> or <a href = "https://docs.djangoproject.com/en/1.11/howto/legacy-databases/">other tricks</a>).

        <li><b>Code simplicity and readability.</b> Because you are pulling in data using well-known modules, there is no mystery for folks about how to build the database.</li>

        <li><b>Security</b>. Because so many people work on these frameworks and obsess about keeping their apps secure, there is much less room for foul play like injection attacks. You are relying on extremely well-vetted methods when interacting with your database.</li>
    </ol>

    <p>
    Caveat: <i>There is no free lunch</i>. The cost of having all this integrated into the project is that your project will be more complicated than if you just yank in a database made elsewhere. You may also lose some of the modularity gained from rolling your own database in a standalone module. Frankly, these minor costs seems worth the above benefits. Django is an extremely popular framework that has been through many design cycles in the Crucible, so I'd rather just lean on their  methods than cook my own.
  </p>

<h3>How to?</h3>
<p>
  When you submit a user-name, it will trigger the request at Bungie for that player's information. If the user exists, a helper function (<i>utils.save_user()</i>)  binds the data to a form that represents the User model class (forms.SubmitUser), and then adds that data to the database if the data are valid.
</p>

<p>
  The class representing the form is simple to make when you use ModelForms.
</p>

<pre>
  class SubmitUser(forms.ModelForm):
      class Meta:
          model = User
          fields = ['display_name', 'user_id']
</pre>

<p>
  The key lines of code from <i>utils.add_user</i>:
</p>

<pre>
        user_data = {'display_name': player_search_response[0]['displayName'], 'user_id': player_search_response[0]['membershipId']}
        submit_user_form = SubmitUser(user_data) #binding data to form
        #Validate and save data
        if submit_user_form.is_valid():
            submit_user_form.save() #save data to database
</pre>

<p>
  After getting data from the api, you fill a dictionary that corresponds to the fields of the model and put it in <i>user_data</i>, and then bind this data to the form in the second line. Finally, you use the built-in validation and save methods. That's it! You have pulled in your data via a form by feeding it a dictionary with the required data. Once the form is bound with the data, it doesn't matter how it got bound: you are now free to use the standard set of procedures as usual.
</p>

<h3>Forms irl</h3>
<p>
  This example is simplistic: you typically wouldn't have a user enter data by hand to get this process started (note the form for submitting the user's name is not the same as the one that includes all the user's information: it is just a trick to get things going). In real life you could get a list of user names from <a href = "https://bungie-net.github.io/multi/operation_get_GroupV2-GetMembersOfGroup.html">GetMembersOfGroup</a>, and then run something like the above on each member of that list. Then, to automate this update, you would use cron or celery.
</p>



{% endblock %}
